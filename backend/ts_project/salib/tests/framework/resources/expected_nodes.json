{
  "transformer": [
    {
      "type": "StdNormalize",
      "desc": "Normalize data such that mean = 0 and std dev = 1",
      "display": "Standard normalization",
      "params": [],
      "inputs": {
        "num_required_inputs": 1,
        "names": [
          "input"
        ]
      }
    },
    {
      "type": "Shift",
      "desc": "Shift series in time by a fixed time delta",
      "display": "Time shift",
      "params": [
        {
          "id": "delta",
          "type": "String",
          "display": "Time delta",
          "desc": "Time delta to shift (eg: 1h)",
          "conditions": [],
          "value": "12h"
        }
      ],
      "inputs": {
        "num_required_inputs": 1,
        "names": [
          "input"
        ]
      }
    },
    {
      "type": "Identity",
      "desc": "Identity - apply no transformation",
      "display": "Identity",
      "params": [],
      "inputs": {
        "num_required_inputs": 1,
        "names": [
          "input"
        ]
      }
    },
    {
      "type": "EMA",
      "desc": "Exponential moving average with decay rate",
      "display": "Exponential moving average",
      "params": [
        {
          "id": "decay",
          "type": "BoundedFloat",
          "display": "Decay",
          "desc": "Decay rate",
          "conditions": [],
          "value": 0.9,
          "min": 0,
          "max": 1,
          "strict_min": false,
          "strict_max": false
        }
      ],
      "inputs": {
        "num_required_inputs": 1,
        "names": [
          "input"
        ]
      }
    },
    {
      "type": "Difference",
      "desc": "Difference operator",
      "display": "Difference",
      "params": [
        {
          "id": "metric",
          "type": "Select",
          "display": "Difference metric",
          "desc": "Difference metric between window values",
          "conditions": [],
          "value": "sub",
          "options": [
            {
              "code": "sub",
              "display": "Substract"
            },
            {
              "code": "l1",
              "display": "L1 distance metric (mod sum)"
            },
            {
              "code": "rel_diff",
              "display": "Relative difference"
            },
            {
              "code": "abs_rel_diff",
              "display": "Absolute relative difference"
            }
          ]
        }
      ],
      "inputs": {
        "num_required_inputs": 2,
        "names": [
          "left",
          "right"
        ]
      }
    },
    {
      "type": "RollingAggregate",
      "desc": "Rolling aggregate",
      "display": "Rolling Aggregate",
      "params": [
        {
          "id": "window",
          "type": "String",
          "display": "Window",
          "desc": "Window size in time interval (eg: 12h)",
          "conditions": [],
          "value": "12h"
        },
        {
          "id": "center",
          "type": "Boolean",
          "display": "Center",
          "desc": "Center aggregation window around value",
          "conditions": [],
          "value": false
        },
        {
          "id": "min_periods",
          "type": "BoundedInt",
          "display": "Min. periods",
          "desc": "Min number of periods",
          "conditions": [],
          "value": 0,
          "min": 0,
          "max": null
        },
        {
          "id": "agg_method",
          "type": "Select",
          "display": "Aggregation",
          "desc": "Aggregation method",
          "conditions": [],
          "value": "mean",
          "options": [
            {
              "code": "mean",
              "display": "Mean"
            },
            {
              "code": "median",
              "display": "Median"
            },
            {
              "code": "sum",
              "display": "Sum"
            },
            {
              "code": "min",
              "display": "Min"
            },
            {
              "code": "max",
              "display": "Max"
            },
            {
              "code": "quantile",
              "display": "Quantile"
            },
            {
              "code": "iqr",
              "display": "Inter-quartile range"
            },
            {
              "code": "idr",
              "display": "Inter-decile range"
            },
            {
              "code": "count",
              "display": "Value count"
            },
            {
              "code": "nnz",
              "display": "Non zero count"
            },
            {
              "code": "nunique",
              "display": "Unique count"
            },
            {
              "code": "std",
              "display": "Sample standard dev."
            },
            {
              "code": "var",
              "display": "Sample variance"
            },
            {
              "code": "skew",
              "display": "Sample skewness"
            },
            {
              "code": "kurt",
              "display": "Sample kurtosis"
            }
          ]
        },
        {
          "id": "quantile_range",
          "type": "BoundedFloat",
          "display": "Quantile range",
          "desc": "Quantile range [q;1-q]",
          "conditions": [
            {
              "type": "param_equals_value",
              "args": {
                "param": "agg_method",
                "value": "quantile"
              }
            }
          ],
          "value": 0.25,
          "min": 0,
          "max": 0.5,
          "strict_min": false,
          "strict_max": false
        }
      ],
      "inputs": {
        "num_required_inputs": 1,
        "names": [
          "input"
        ]
      }
    },
    {
      "type": "STL",
      "desc": "Seasonal-Trend decomposition (LOESS)",
      "display": "STL decomposition",
      "params": [
        {
          "id": "output",
          "type": "Select",
          "display": "Output",
          "desc": "STL output",
          "conditions": [],
          "value": "trend",
          "options": [
            {
              "code": "trend",
              "display": "Trend"
            },
            {
              "code": "seasonal",
              "display": "Seasonality"
            },
            {
              "code": "resid",
              "display": "Residual"
            }
          ]
        },
        {
          "id": "period",
          "type": "String",
          "display": "Period",
          "desc": "Expected seasonality in periods or time interval (eg: 12h)",
          "conditions": [],
          "value": "7d"
        },
        {
          "id": "robust",
          "type": "Boolean",
          "display": "Robust",
          "desc": "Tolerate larger errors using LOWESS",
          "conditions": [],
          "value": true
        }
      ],
      "inputs": {
        "num_required_inputs": 1,
        "names": [
          "input"
        ]
      }
    },
    {
      "type": "Seasonal decompose",
      "desc": "Seasonal & trend decomposition using averages",
      "display": "Seasonal decomposition",
      "params": [
        {
          "id": "output",
          "type": "Select",
          "display": "Output",
          "desc": "Seasonal decompose output",
          "conditions": [],
          "value": "trend",
          "options": [
            {
              "code": "trend",
              "display": "Trend"
            },
            {
              "code": "seasonal",
              "display": "Seasonality"
            },
            {
              "code": "resid",
              "display": "Residual"
            }
          ]
        },
        {
          "id": "period",
          "type": "String",
          "display": "Period",
          "desc": "Expected seasonality in periods or time interval (eg: 12h)",
          "conditions": [],
          "value": "7d"
        },
        {
          "id": "two_sided",
          "type": "Boolean",
          "display": "Two sided",
          "desc": "Calculate moving averages in both directions for robustness",
          "conditions": [],
          "value": true
        }
      ],
      "inputs": {
        "num_required_inputs": 1,
        "names": [
          "input"
        ]
      }
    },
    {
      "type": "AutoRegression",
      "desc": "Auto-regression with lags & seasonality",
      "display": "Auto-Regression",
      "params": [
        {
          "id": "period",
          "type": "String",
          "display": "Period",
          "desc": "Expected seasonality in periods or time interval (eg: 12h)",
          "conditions": [],
          "value": "7d"
        },
        {
          "id": "lags",
          "type": "BoundedInt",
          "display": "Lags",
          "desc": "Number of lags to use",
          "conditions": [],
          "value": 6,
          "min": 0,
          "max": null
        }
      ],
      "inputs": {
        "num_required_inputs": 1,
        "names": [
          "input"
        ]
      }
    },
    {
      "type": "ALMA",
      "desc": "Arnaud Legoux moving average",
      "display": "Arnaud Legoux moving average",
      "params": [
        {
          "id": "window",
          "type": "String",
          "display": "Window",
          "desc": "Window size in periods or time interval (eg: 12h)",
          "conditions": [],
          "value": "12h"
        }
      ],
      "inputs": {
        "num_required_inputs": 1,
        "names": [
          "input"
        ]
      }
    }
  ],
  "detector": [
    {
      "type": "SimpleThreshold",
      "desc": "Detect values outside of bounds",
      "display": "Simple Threshold",
      "params": [
        {
          "id": "inside",
          "type": "Boolean",
          "display": "Inside",
          "desc": "If true, value must be within bounds",
          "conditions": [],
          "value": false
        },
        {
          "id": "strict",
          "type": "Boolean",
          "display": "Strict",
          "desc": "Strict comparison on bounds",
          "conditions": [],
          "value": false
        },
        {
          "id": "lower",
          "type": "Float",
          "display": "Lower",
          "desc": "Lower bound",
          "conditions": [],
          "value": null
        },
        {
          "id": "upper",
          "type": "Float",
          "display": "Upper",
          "desc": "Upper bound",
          "conditions": [],
          "value": null
        }
      ],
      "inputs": {
        "num_required_inputs": 1,
        "names": [
          "input"
        ]
      }
    },
    {
      "type": "Quantile",
      "desc": "Compare values with given quantiles and identify anomalies beyond inter-quantile range",
      "display": "Quantile",
      "params": [
        {
          "id": "high",
          "type": "BoundedFloat",
          "display": "Quantile upper",
          "desc": "Quantile above which we consider anomaly (0-1) - leave empty for no limit",
          "conditions": [],
          "value": 0.9,
          "min": 0,
          "max": 1,
          "strict_min": false,
          "strict_max": false
        },
        {
          "id": "low",
          "type": "BoundedFloat",
          "display": "Quantile lower",
          "desc": "Quantile below which we consider anomaly (0-1) - leave empty for no limit",
          "conditions": [],
          "value": 0.1,
          "min": 0,
          "max": 1,
          "strict_min": false,
          "strict_max": false
        }
      ],
      "inputs": {
        "num_required_inputs": 1,
        "names": [
          "input"
        ]
      }
    },
    {
      "type": "InterQuartileRange",
      "desc": "Compare values with 1st and 3rd quartiles and identify anomalies beyond inter-quartile range adjusted by a scale factor",
      "display": "Inter-quartile range",
      "params": [
        {
          "id": "scale",
          "type": "Float",
          "display": "Range scale factor",
          "desc": "Factor used to determine the bound of normal range (betweeen Q1-c*IQR and Q3+c*IQR)",
          "conditions": [],
          "value": 0.3
        }
      ],
      "inputs": {
        "num_required_inputs": 1,
        "names": [
          "input"
        ]
      }
    }
  ],
  "aggregator": [
    {
      "type": "Union",
      "desc": "Combine all anomalies from sources",
      "display": "Union",
      "params": [],
      "inputs": {
        "num_required_inputs": null,
        "names": []
      }
    },
    {
      "type": "Intersect",
      "desc": "Combine and merge overlapping anomalies from sources",
      "display": "Intersect",
      "params": [
        {
          "id": "resolution",
          "type": "Select",
          "display": "Resolution",
          "desc": "Combine using temporal axis or anomaly wise",
          "conditions": [],
          "value": "temporal",
          "options": [
            {
              "code": "temporal",
              "display": "Temporal"
            },
            {
              "code": "anomaly",
              "display": "Anomaly"
            }
          ]
        },
        {
          "id": "strict",
          "type": "Boolean",
          "display": "Strict",
          "desc": "If true anomalies must match exact bounds, otherwise, any overlap is considered valid",
          "conditions": [
            {
              "type": "param_equals_value",
              "args": {
                "param": "resolution",
                "value": "anomaly"
              }
            }
          ],
          "value": true
        }
      ],
      "inputs": {
        "num_required_inputs": null,
        "names": []
      }
    }
  ]
}